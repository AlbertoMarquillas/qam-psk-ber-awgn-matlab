function [ber, numBits] = simula_qam3(EbNo, maxNumErrs, maxNumBits)
   %Funció i Sortida
   %   La línia de dalt defineix una funció que es diu simula_qam3 que simula
   %   una transmissió de 16-QAM a un canal AWGN
   %   Entrades:
   %       EbNo: relació d'energia per bit a densitat de soroll (en dB)
   %       maxNumErrs: nombre màxim d'errors a acumular abans de parar la
   %       simulació
   %       maxNumBits: nombre màxim de bits a simular.
   %   Sortides:
   %       ber: taxa d'error de bits (Bit Error Rate)
   %       numBits: nombre total de bits processats a la simulació
  
   %Verificació del nombre d'arguments:
   %   Aquesta instrucció comprova que la funció es truqui amb exactament 3
   %   arguments. Si no és així, es llença un error.
   narginchk(3,3)
  
   %Ús de funcions extrínseques:
   %   Això indica a MATLAB Coder que la funció isBERToolSimulationStopped no
   %   es compilarà (es tractarà com una funció externa).
   %   En simulacions amb BERTool es permet que l'usuari interrompi la
   %   simulació, i aquesta funció comprova aquesta condició.
   
   coder.extrinsic('isBERToolSimulationStopped')
   %Inicialització de variables de control
   %   S'inicialitzen a zero les variables:
   %       totErr: acumulador del nombre total d'errors detectats
   %       numBits: acumulador del nombre total de bits simulats
   %   A simulacions Monte Carlo es necessiten comptadors per determinar quan
   %   s'han aconseguit els llindars preestablerts
   totErr  = 0;
   numBits = 0;


   %Definició de la constel·lació 16-QAM normalitzada:
   %   Es defineixen els 16 símbols complexos que representen la constel·lació de
   %   16-QAM amb amplitud de +/-1 i +/- 3.
   %   Es multiplica per 1/((10)^(1/2)) per normalitzar la potència mitjana
   %   a 1, ja que la potència mitjana sería 10
   %   La normalització és important perquè la potència del senyal sigui
   %   consistent i es pugui relacionar correctament amb la potència del
   %   soroll (Pn).
   %   En 16.QAM la eficiència espectral es major ja que k=4, pero
   %   requereix mes Eb/N0 per aconsseguir la mateixa BER que modulacions
   %   d'ordre inferior

   constelBits = ['0000';
                   '0100';
                   '1000';
                   '1100';
                   '0001';
                   '0101';
                   '1001';
                   '1101';
                   '0011'; 
                   '0111'; 
                   '1011'; 
                   '1111'; 
                   '0010'; 
                   '0110'; 
                   '1010'; 
                   '1110'];


   %Definició de la constel·lació 16-QAM normalitzada:
   %   Es defineixen els 16 símbols complexos que representen la constel·lació de
   %   16-QAM amb amplitud de +/-1 i +/- 3.
   %   Es multiplica per 1/((10)^(1/2)) per normalitzar la potència mitjana
   %   a 1, ja que la potència mitjana sería 10
   %   La normalització és important perquè la potència del senyal sigui
   %   consistent i es pugui relacionar correctament amb la potència del
   %   soroll (Pn).
   %   En 16.QAM la eficiència espectral es major ja que k=4, pero
   %   requereix mes Eb/N0 per aconsseguir la mateixa BER que modulacions
   %   d'ordre inferior

   
   constelSymb = (1/sqrt(10)) * [ -3+3i; -1+3i; 3+3i; 1+3i; ...
                               -3+1i; -1+1i; 3+1i; 1+1i; ...
                               -3-1i; -1-1i; 3-1i; 1-1i; ...
                               -3-3i; -1-3i; 3-3i; 1-3i ];

   
   %Número de símbols
   %   Es calcula cantidadSimbolos, que és el nombre de punts de la constel·lació
   %   En aquest cas cantidadSimbolos=8
   cantidadSimbolos = length(constelSymb);

%Bits per símbol:
%   Es calcula el nombre de bits que es poden representar amb cada símbol,
%   fent servir la fórmula bitsSimbolo=log2(cantidadSimbolos)
%   Per cantidadSimbolos=8, bitsSimbolo=3
%   Aquest paràmetre és clau per determinar l'eficiència de la modulació
%   (més bits per símbol implica major eficiència espectral, però també major
%   susceptibilitat al soroll)

   bitsSimbolo = log2(cantidadSimbolos);
  
  
   %Número de bits per bloc
   %   Defineix quants bits se simularan a cada iteració del bucle (bloc de
   %   simulació)
   %   Aquí se simulen 10000 símbols, i per això el nombre de bits en cada bloc
   %   serà de 10000 * bitsSimbolo (on bitsSimbolo = 3)
   nbitsBloc = 10000 * bitsSimbolo;

   %Potència del senyal
   %   Es calcula la potència mitjana del senyal transmès Ps
   %   S'utilitza la mitja del quadrat del valor absolut de cada símbol
   %   La potència del senyal és fonamental per determinar el nivell de soroll
   %   necessari en funció de la relació Eb/N0   
   Ps = mean( abs( constelSymb) .^ 2);

   %Conversió de dB a lineal
   %   Converteix el valor de Eb/N0 de decibels (dB) al seu valor lineal
   %   mitjançant la fórmula 10^(EbNo/10)
   pRuidoEbNo = 10 ^ (EbNo / 10);

   %Càlcul de la potència del soroll
   %   Es calcula Pn, la potència del soroll, fent servir la relació:
   %   Pn=(Ps)/(bitsSimbolo*(Eb/E0))
   %   Donat que l'energia per bit Eb es pot obtenir com (considerant el Ts=1)
   %   Eb=Ps/bitsSimbolo
   %   i sabent que Eb/N0 no és la raó de senyal a soroll, es pot deduir que:
   %   N0=Eb/(Eb/N0)
   %   En aquesta simulació, es fa servir Pn com una aproximació del soroll
   %   que s'afegeix al senyal
   Pn = Ps/(pRuidoEbNo * bitsSimbolo);

   %Longitud del bloc de símbols
   %   Es defineix numSymb com el nombre de símbols que se simularan a cada iteració
   %   del bucle
   numSymb = 10000;
  
   %Bucle de simulació
   %   S'entra en un bucle que continuarà simulant blocs de transmissió fins
   %   que:
   %       - S'hagin acumulat almenys maxNumErrs errors
   %       - S'hagin transmès almenys maxNumBits
   %   Aquest mètode de parada (criteri d'error o de bits) és típic a
   %   simulacions Monte Carlo per garantir resultats estadísticament
   %   significatius sense excedir temps de processament excessius
   while((totErr < maxNumErrs) && (numBits < maxNumBits))
  
       %Detecció de parada manual
       %   Es comprova si l'usuari ha sol·licitat detenir la simulació
       %   Si és així surt del bucle
       if isBERToolSimulationStopped()
           break
       end
  
       %Generació de símbols a transmetre
       %   Es genera un vector de numSymb nombres sencers aleatoris entre 1 i cantidadSimbolos
       %   Cada nombre representa l'índex d'un símbol de la constel·lació
       %   La generació aleatòria assegura que cada símbol es transmeti amb
       %   una igual probabilitat, simulant una font d'informació equiprobable
       txSymb = randi([1 cantidadSimbolos],1,numSymb);
  
       %Mapeig d'índex a símbols
       %   S'utilitza el vector 'txSymb' per seleccionar els símbols
       %   corresponents de 'contel_symb'
       %   Això genera el vector del senyal transmès, on cada posició conté
       %   un valor complex de la constel·lació
       txSig = constelSymb(txSymb);
  
       %Generació del soroll AWGN
       %   Es genera un vector de soroll complex
       %   randn(1, numSymb) produeix numSymb mostres de soroll gaussià real amb mitja 0 i
       %   variància 1
       %   Es genera soroll per les parts real i imaginària, i es multiplica
       %   per (PN/2)^(1/2) per ajustar la variància de cada component
       %   En un canal AWGN, el soroll es complex, i la potència total es
       %   reparteix equitativament entre la part real i la part imaginària
       Soroll = sqrt(Pn / 2) * (randn( 1, numSymb) + 1i * randn( 1, numSymb));
  
       %Senyal rebut
       %   El senyal rebut rxSig és la suma del senyal transmès (convertida en
       %   vector columna amb la transposició ') i el soroll generat
       %   Això simula el pas del senyal per un canal AWGN, on s'afegeix
       %   soroll blanc gaussià al senyal transmès
       rxSig =  txSig.' + Soroll; 
  
       %Demodulació i càlcul d'errors
       %   Es truca a la funció demodqam per demodular el senyal rebut
       %   La funció compara el senal rebut rxSig amb la constel·lació definida
       %   (constel_symb) i el mapeig de bits (constel_bits)
       %   Es calcula el nombre d'errors (nerrors) comparant els bits del
       %   símbol transmés (fent servir txSymb) amb els bits detectats
       %   La demodulació per mínima distància (o detector de màxima
       %   versemblança) és el mètode que es fa servir per decidir quin va ser
       %   el símbol transmès a partir del senyal amb soroll
       [~, nerrors] = demodqam(rxSig, constelSymb, constelBits, txSymb);

       %Acumulació de bits transmesos
       %   S'incrementa el comptador total de bits simulats a la quantitat
       %   corresponent al bloc actual 'nbitsBloc'
       %   Això permet calcular la taxa d'error com la relació entre errors i
       %   bits totals processats
       %   Això permet calcular la taxa d'error com la relació entre errors i
       %   bits totals processatsdd
       numBits = numBits + nbitsBloc;
  
       %Acumulació d'errors
       %   S'actualitza el comptador total d'errors sumant els errors
       %   detectats en aquest bloc
       totErr = totErr + nerrors;
  
   end
  
   %Càlcul final del BER
   %   Es calcula la taxa d'error de bits (BER) dividint el número total
   %   d'errors acumulats entre el nombre total de bits simulats
   %   El BER és una mesura fonamental a comunicacions digitals, indicant la
   %   fracció de bits erronis rebuts. Un BER menor indica un sistema més.
   %   robust enfront del soroll
   ber = totErr/numBits;